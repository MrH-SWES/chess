<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classroom Chess: Sandbox Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        :root {
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --highlight: rgba(100, 210, 100, 0.7);
            --capture: rgba(200, 50, 50, 0.6);
            --last-move: rgba(255, 255, 50, 0.5);
            --selected: rgba(100, 100, 255, 0.5);
            --bg-color: #2c2c2c;
            --text-color: #f0f0f0;
            --panel-bg: rgba(0,0,0,0.3);
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            user-select: none;
        }

        #ui-container {
            width: 98vw;
            height: 95vh;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        /* Top Bar */
        #status-bar {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: var(--panel-bg);
            border-radius: 8px;
            font-size: 1.2rem;
            box-sizing: border-box;
        }

        #turn-indicator span {
            font-weight: bold;
            padding: 2px 10px;
            border-radius: 4px;
            margin-left: 5px;
        }

        /* Middle Section: Captures + Board */
        #game-area {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex: 1;
            width: 100%;
        }

        /* The Board */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            height: min(70vh, 70vw); 
            width: min(70vh, 70vw);
            border: 4px solid #444;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        /* Captured Pieces Sidebars */
        .captured-column {
            display: flex;
            flex-direction: column;
            width: 60px;
            height: min(70vh, 70vw);
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 10px 5px;
            align-items: center;
            gap: 5px;
            overflow-y: auto;
        }
        
        .captured-piece {
            font-size: 2.2rem;
            line-height: 1;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5));
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1rem, 8vmin, 4rem);
            cursor: pointer;
            position: relative;
        }

        .light { background-color: var(--light-square); color: black; }
        .dark { background-color: var(--dark-square); color: black; }
        
        .piece.white { color: #fff; text-shadow: 0 0 2px #000; z-index: 2; }
        .piece.black { color: #000; text-shadow: 0 0 1px #fff; z-index: 2; }

        /* Highlights */
        .highlight::after {
            content: ''; position: absolute; width: 30%; height: 30%;
            background-color: rgba(0,0,0,0.2); border-radius: 50%; z-index: 1;
        }
        .possible-move { background-color: var(--highlight) !important; }
        .possible-capture { background-color: var(--capture) !important; }
        .selected { background-color: var(--selected) !important; }
        .last-move { box-shadow: inset 0 0 0 4px var(--last-move); }

        /* Coordinates */
        .coord {
            position: absolute; font-size: 0.8rem; font-weight: bold;
            color: inherit; pointer-events: none; opacity: 0.7;
        }
        .coord-rank { top: 2px; left: 4px; }
        .coord-file { bottom: 2px; right: 4px; }

        /* Controls */
        #controls { display: flex; gap: 8px; height: 50px; width: 100%; max-width: 600px; }
        button {
            flex: 1; font-size: 1rem; border: none; border-radius: 5px;
            cursor: pointer; background-color: #555; color: white;
            transition: background 0.1s; display: flex; justify-content: center; align-items: center;
        }
        button:hover { background-color: #666; }
        button:active { background-color: #777; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        button.active-mode { background-color: #d64541; color: white; font-weight: bold; }

        /* Setup Palette */
        #setup-palette {
            display: none; flex-wrap: wrap; gap: 5px; background: #333;
            padding: 10px; border-radius: 8px; justify-content: center;
            width: 100%; max-width: 600px;
        }
        .palette-piece {
            width: 40px; height: 40px; font-size: 1.8rem;
            display: flex; justify-content: center; align-items: center;
            background: #444; border-radius: 4px; cursor: pointer;
            border: 2px solid transparent;
        }
        .palette-piece.selected-tool { border-color: #fff; background: #666; }
        .palette-sep { width: 2px; background: #666; margin: 0 5px; }

        @media (max-width: 800px) {
            #game-area { flex-direction: column; }
            .captured-column { flex-direction: row; width: 100%; height: 50px; max-width: 600px; }
            #board { height: 90vw; width: 90vw; }
        }
    </style>
</head>
<body>

    <div id="ui-container">
        
        <div id="status-bar">
            <div id="turn-indicator">Turn: <span id="turn-text" style="background: white; color: black;">White</span></div>
            <div id="game-status"></div>
        </div>

        <div id="game-area">
            <div id="captured-white" class="captured-column"></div>
            <div id="board"></div>
            <div id="captured-black" class="captured-column"></div>
        </div>

        <div id="setup-palette">
            </div>

        <div id="controls">
            <button id="btn-reset">Reset</button>
            <button id="btn-back">‚óÑ</button>
            <button id="btn-fwd">‚ñ∫</button>
            <button id="btn-flip">Flip</button>
            <button id="btn-setup">üõ† Setup</button>
        </div>
    </div>

    <script>
        // --- State Management ---
        const game = new Chess();
        let historyStack = [game.fen()];
        let currentHistoryIndex = 0;
        let selectedSquare = null;
        let orientation = 'white'; 
        let isSetupMode = false;
        let setupTool = 'cursor'; // Default to "Free Move" in setup

        const pieceIcons = {
            'p': '‚ôü', 'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö',
            'P': '‚ôü', 'R': '‚ôú', 'N': '‚ôû', 'B': '‚ôù', 'Q': '‚ôõ', 'K': '‚ôö'
        };

        const boardEl = document.getElementById('board');
        const turnText = document.getElementById('turn-text');
        const statusText = document.getElementById('game-status');
        const paletteEl = document.getElementById('setup-palette');
        const capWhiteEl = document.getElementById('captured-white');
        const capBlackEl = document.getElementById('captured-black');

        // --- Core Rendering ---
        function createBoard() {
            boardEl.innerHTML = '';
            const boardState = game.board();
            
            const rows = orientation === 'white' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
            const cols = orientation === 'white' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];

            let lastMove = null;
            if (currentHistoryIndex > 0 && !isSetupMode) {
                // We rely on internal game state history for highlights in normal play
                // In Setup mode, history is often wiped, so we skip this
                const history = game.history({ verbose: true });
                if (history.length > 0) {
                    lastMove = history[history.length - 1];
                }
            }

            rows.forEach(row => {
                cols.forEach(col => {
                    const squareDiv = document.createElement('div');
                    const isDark = (row + col) % 2 === 1;
                    const fileChar = String.fromCharCode(97 + col);
                    const rankChar = String.fromCharCode(56 - row);
                    const squareName = fileChar + rankChar;
                    
                    squareDiv.className = `square ${isDark ? 'dark' : 'light'}`;
                    squareDiv.dataset.square = squareName;

                    if (lastMove && (squareName === lastMove.from || squareName === lastMove.to)) {
                        squareDiv.classList.add('last-move');
                    }

                    const piece = boardState[row][col];
                    if (piece) {
                        const span = document.createElement('span');
                        span.className = `piece ${piece.color === 'w' ? 'white' : 'black'}`;
                        span.textContent = pieceIcons[piece.type];
                        squareDiv.appendChild(span);
                    }

                    // Coordinates
                    const isLeftEdge = (orientation === 'white' && col === 0) || (orientation === 'black' && col === 7);
                    const isBottomEdge = (orientation === 'white' && row === 7) || (orientation === 'black' && row === 0);

                    if (isLeftEdge) {
                        const rankLabel = document.createElement('span');
                        rankLabel.className = 'coord coord-rank';
                        rankLabel.textContent = rankChar;
                        squareDiv.appendChild(rankLabel);
                    }
                    if (isBottomEdge) {
                        const fileLabel = document.createElement('span');
                        fileLabel.className = 'coord coord-file';
                        fileLabel.textContent = fileChar;
                        squareDiv.appendChild(fileLabel);
                    }

                    squareDiv.addEventListener('click', () => handleSquareClick(squareName));
                    boardEl.appendChild(squareDiv);
                });
            });
            updateStatus();
            if(!isSetupMode) updateCaptured(); // Don't update captured in setup (it breaks)
        }

        // --- Interaction Logic ---
        function handleSquareClick(square) {
            if (isSetupMode) {
                handleSetupClick(square);
            } else {
                handlePlayClick(square);
            }
        }

        function handlePlayClick(square) {
            if (currentHistoryIndex !== historyStack.length - 1) return;

            const piece = game.get(square);

            if (selectedSquare === square) {
                selectedSquare = null;
                renderHighlights();
                return;
            }

            if (selectedSquare) {
                const move = game.move({
                    from: selectedSquare,
                    to: square,
                    promotion: 'q'
                });

                if (move) {
                    selectedSquare = null;
                    addToHistory();
                    createBoard();
                    return;
                }
            }

            if (piece && piece.color === game.turn()) {
                selectedSquare = square;
                renderHighlights();
            } else {
                selectedSquare = null;
                renderHighlights();
            }
        }

        function handleSetupClick(square) {
            // 1. Paint/Trash Logic
            if (setupTool !== 'cursor') {
                if (setupTool === 'trash') {
                    game.remove(square);
                } else {
                    const color = setupTool[0];
                    const type = setupTool[1].toLowerCase();
                    game.remove(square);
                    game.put({ type: type, color: color }, square);
                }
                createBoard();
                return;
            }

            // 2. "Cursor" (Free Move) Logic
            const piece = game.get(square);

            // If clicking the same square, deselect
            if (selectedSquare === square) {
                selectedSquare = null;
                renderHighlights();
                return;
            }

            // If a piece is selected, try to move it to the new square
            if (selectedSquare) {
                // FORCE TURN: Ensure engine allows the move by temporarily swapping turn if needed
                const selectedPiece = game.get(selectedSquare);
                const currentTurn = game.turn();
                
                // If it's not the selected piece's turn, we force the FEN to make it their turn
                if (selectedPiece.color !== currentTurn) {
                    let fen = game.fen();
                    const parts = fen.split(' ');
                    parts[1] = selectedPiece.color; // Force active color
                    parts[3] = '-'; // Clear en passant to avoid errors in manual manipulation
                    game.load(parts.join(' '));
                }

                // Attempt Move
                const move = game.move({
                    from: selectedSquare,
                    to: square,
                    promotion: 'q'
                });

                if (move) {
                    selectedSquare = null;
                    // Note: We do NOT add to historyStack in setup mode to avoid corrupting undo/redo
                    // But we DO re-render
                    createBoard();
                    return;
                }
            }

            // Select a piece (Allow selecting EITHER color)
            if (piece) {
                selectedSquare = square;
                
                // Force engine turn to this piece so game.moves() returns valid data
                if (piece.color !== game.turn()) {
                    let fen = game.fen();
                    const parts = fen.split(' ');
                    parts[1] = piece.color;
                    parts[3] = '-';
                    game.load(parts.join(' '));
                }
                
                renderHighlights();
            } else {
                selectedSquare = null;
                renderHighlights();
            }
        }

        function renderHighlights() {
            document.querySelectorAll('.square').forEach(el => {
                el.classList.remove('selected', 'possible-move', 'possible-capture');
            });

            if (!selectedSquare) return;

            const selectedEl = document.querySelector(`[data-square="${selectedSquare}"]`);
            if (selectedEl) selectedEl.classList.add('selected');

            // game.moves() relies on whose turn it is. 
            // In setup 'cursor' mode, we have already forced the turn to the selected piece in handleSetupClick
            const moves = game.moves({ square: selectedSquare, verbose: true });
            moves.forEach(move => {
                const targetEl = document.querySelector(`[data-square="${move.to}"]`);
                if (!targetEl) return;
                if (game.get(move.to)) targetEl.classList.add('possible-capture');
                else targetEl.classList.add('possible-move');
            });
        }

        // --- Captured Pieces Logic ---
        function updateCaptured() {
            const history = game.history({ verbose: true });
            const capturedW = []; 
            const capturedB = []; 
            const values = { 'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1 };

            history.forEach(move => {
                if (move.captured) {
                    if (move.color === 'w') capturedB.push(move.captured);
                    else capturedW.push(move.captured);
                }
            });

            capturedW.sort((a,b) => values[b] - values[a]);
            capturedB.sort((a,b) => values[b] - values[a]);

            renderCapturedContainer(capWhiteEl, capturedW, 'white');
            renderCapturedContainer(capBlackEl, capturedB, 'black');
        }

        function renderCapturedContainer(container, pieces, colorClass) {
            container.innerHTML = '';
            pieces.forEach(p => {
                const span = document.createElement('span');
                span.className = `captured-piece piece ${colorClass}`;
                span.textContent = pieceIcons[p];
                container.appendChild(span);
            });
        }

        // --- History & Game State ---
        function addToHistory() {
            if (currentHistoryIndex < historyStack.length - 1) {
                historyStack = historyStack.slice(0, currentHistoryIndex + 1);
            }
            historyStack.push(game.fen());
            currentHistoryIndex++;
            updateStatus();
        }

        function updateStatus() {
            if (isSetupMode) {
                // Setup Mode Status
                statusText.textContent = "SETUP / FREE MOVE";
                statusText.style.color = "#d64541";
                turnText.textContent = "-";
                turnText.style.background = "#555";
                turnText.style.color = "#fff";
                
                // Disable Back/Fwd during setup because we are breaking the timeline
                document.getElementById('btn-back').disabled = true;
                document.getElementById('btn-fwd').disabled = true;
                
            } else {
                // Normal Play Status
                const turn = game.turn() === 'w' ? 'White' : 'Black';
                turnText.textContent = turn;
                turnText.style.background = turn === 'White' ? '#fff' : '#333';
                turnText.style.color = turn === 'White' ? '#000' : '#fff';

                statusText.style.color = "#ccc";
                if (game.in_checkmate()) statusText.textContent = "Checkmate!";
                else if (game.in_draw()) statusText.textContent = "Draw!";
                else if (game.in_check()) statusText.textContent = "Check!";
                else statusText.textContent = "";

                document.getElementById('btn-back').disabled = currentHistoryIndex === 0;
                document.getElementById('btn-fwd').disabled = currentHistoryIndex === historyStack.length - 1;
            }
            
            document.getElementById('btn-flip').textContent = orientation === 'white' ? 'Flip ‚ü≥' : 'Flip ‚ü≤';
        }

        // --- Setup / Palette Logic ---
        function initPalette() {
            // Added 'cursor' as the first tool
            const pieces = ['cursor', 'sep', 'wP', 'wN', 'wB', 'wR', 'wQ', 'wK', 'sep', 'bP', 'bN', 'bB', 'bR', 'bQ', 'bK', 'sep', 'trash'];
            paletteEl.innerHTML = '';
            
            pieces.forEach(p => {
                if (p === 'sep') {
                    const sep = document.createElement('div');
                    sep.className = 'palette-sep';
                    paletteEl.appendChild(sep);
                    return;
                }
                const div = document.createElement('div');
                div.className = 'palette-piece';
                
                if (p === 'cursor') {
                    div.innerHTML = 'üëÜ'; // Cursor Icon
                    div.title = "Free Move Mode";
                } else if (p === 'trash') {
                    div.innerHTML = 'üóëÔ∏è';
                } else {
                    const color = p[0] === 'w' ? 'white' : 'black';
                    const type = p[1].toLowerCase();
                    div.innerHTML = `<span class="piece ${color}">${pieceIcons[type]}</span>`;
                }

                div.addEventListener('click', () => {
                    setupTool = p;
                    document.querySelectorAll('.palette-piece').forEach(el => el.classList.remove('selected-tool'));
                    div.classList.add('selected-tool');
                });
                
                if (p === setupTool) div.classList.add('selected-tool');
                paletteEl.appendChild(div);
            });
            
            const clearBtn = document.createElement('button');
            clearBtn.textContent = "Clear All";
            clearBtn.style.width = "100%";
            clearBtn.style.marginTop = "5px";
            clearBtn.style.background = "#c0392b";
            clearBtn.onclick = () => { game.clear(); createBoard(); };
            paletteEl.appendChild(clearBtn);
        }

        // --- Event Listeners ---
        document.getElementById('btn-back').addEventListener('click', () => {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                game.load(historyStack[currentHistoryIndex]);
                selectedSquare = null;
                createBoard();
            }
        });

        document.getElementById('btn-fwd').addEventListener('click', () => {
            if (currentHistoryIndex < historyStack.length - 1) {
                currentHistoryIndex++;
                game.load(historyStack[currentHistoryIndex]);
                selectedSquare = null;
                createBoard();
            }
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            if(confirm("Reset the board to start?")) {
                game.reset();
                historyStack = [game.fen()];
                currentHistoryIndex = 0;
                selectedSquare = null;
                isSetupMode = false;
                document.getElementById('setup-palette').style.display = 'none';
                createBoard();
            }
        });

        document.getElementById('btn-flip').addEventListener('click', () => {
            orientation = orientation === 'white' ? 'black' : 'white';
            createBoard();
        });

        document.getElementById('btn-setup').addEventListener('click', () => {
            isSetupMode = !isSetupMode;
            const btn = document.getElementById('btn-setup');
            const palette = document.getElementById('setup-palette');
            const capW = document.getElementById('captured-white');
            const capB = document.getElementById('captured-black');
            
            if (isSetupMode) {
                btn.classList.add('active-mode');
                palette.style.display = 'flex';
                btn.textContent = "Done";
                setupTool = 'cursor'; // Default to free move
                initPalette(); // Re-render palette to ensure highlight
                // Clear captured because we are about to break the timeline
                capW.innerHTML = '';
                capB.innerHTML = '';
            } else {
                btn.classList.remove('active-mode');
                palette.style.display = 'none';
                btn.textContent = "üõ† Setup";
                // When finishing setup, we establish a new timeline
                historyStack = [game.fen()];
                currentHistoryIndex = 0;
            }
            selectedSquare = null;
            renderHighlights();
            updateStatus();
        });

        initPalette();
        createBoard();

    </script>
</body>
</html>
