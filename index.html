<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classroom Chess Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        :root {
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --highlight: rgba(100, 210, 100, 0.7); /* Green - Moves */
            --capture: rgba(200, 50, 50, 0.6);     /* Red - Captures */
            --last-move: rgba(255, 255, 50, 0.5);  /* Yellow - Last Move */
            --selected: rgba(100, 100, 255, 0.5);  /* Blue - Selection */
            --bg-color: #2c2c2c;
            --text-color: #f0f0f0;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #ui-container {
            width: 95vmin;
            max-width: 650px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Top Bar */
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            font-size: 1.1rem;
        }

        #turn-indicator span {
            font-weight: bold;
            padding: 2px 10px;
            border-radius: 4px;
            margin-left: 5px;
        }

        /* The Board */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 4px solid #444;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem; /* Big pieces */
            cursor: pointer;
            position: relative;
        }

        .light { background-color: var(--light-square); color: black; }
        .dark { background-color: var(--dark-square); color: black; }
        
        /* Piece Colors */
        .piece.white { color: #fff; text-shadow: 0 0 2px #000; z-index: 2; }
        .piece.black { color: #000; text-shadow: 0 0 1px #fff; z-index: 2; }

        /* Highlights */
        .highlight::after {
            content: ''; position: absolute; width: 30%; height: 30%;
            background-color: rgba(0,0,0,0.2); border-radius: 50%; z-index: 1;
        }
        .possible-move { background-color: var(--highlight) !important; }
        .possible-capture { background-color: var(--capture) !important; }
        .selected { background-color: var(--selected) !important; }
        .last-move { box-shadow: inset 0 0 0 4px var(--last-move); }

        /* Coordinates (a-h, 1-8) */
        .coord {
            position: absolute;
            font-size: 0.8rem;
            font-weight: bold;
            color: inherit;
            pointer-events: none;
            opacity: 0.7;
        }
        .coord-rank { top: 2px; left: 4px; }
        .coord-file { bottom: 2px; right: 4px; }

        /* Controls Area */
        #controls { display: flex; gap: 8px; height: 50px; }
        
        button {
            flex: 1; font-size: 1rem; border: none; border-radius: 5px;
            cursor: pointer; background-color: #555; color: white;
            transition: background 0.1s; display: flex; justify-content: center; align-items: center;
        }
        button:hover { background-color: #666; }
        button:active { background-color: #777; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        button.active-mode { background-color: #d64541; color: white; font-weight: bold; }

        /* Setup Palette (Hidden by default) */
        #setup-palette {
            display: none; /* Flex when active */
            flex-wrap: wrap;
            gap: 5px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
            justify-content: center;
        }
        
        .palette-piece {
            width: 40px; height: 40px;
            font-size: 1.8rem;
            display: flex; justify-content: center; align-items: center;
            background: #444; border-radius: 4px; cursor: pointer;
            border: 2px solid transparent;
        }
        .palette-piece.selected-tool { border-color: #fff; background: #666; }
        .palette-sep { width: 2px; background: #666; margin: 0 5px; }

    </style>
</head>
<body>

    <div id="ui-container">
        
        <div id="status-bar">
            <div id="turn-indicator">Turn: <span id="turn-text" style="background: white; color: black;">White</span></div>
            <div id="game-status"></div>
        </div>

        <div id="board"></div>

        <div id="setup-palette">
            </div>

        <div id="controls">
            <button id="btn-reset">Reset</button>
            <button id="btn-back">‚óÑ</button>
            <button id="btn-fwd">‚ñ∫</button>
            <button id="btn-flip">Flip</button>
            <button id="btn-setup">üõ† Setup</button>
        </div>
    </div>

    <script>
        // --- State Management ---
        const game = new Chess();
        let historyStack = [game.fen()];
        let currentHistoryIndex = 0;
        let selectedSquare = null;
        let orientation = 'white'; // 'white' or 'black'
        let isSetupMode = false;
        let setupTool = 'wP'; // Default tool: White Pawn

        // Unicode Pieces
        const pieceIcons = {
            'p': '‚ôü', 'r': '‚ôú', 'n': '‚ôû', 'b': '‚ôù', 'q': '‚ôõ', 'k': '‚ôö',
            'P': '‚ôü', 'R': '‚ôú', 'N': '‚ôû', 'B': '‚ôù', 'Q': '‚ôõ', 'K': '‚ôö'
        };

        // --- DOM Elements ---
        const boardEl = document.getElementById('board');
        const turnText = document.getElementById('turn-text');
        const statusText = document.getElementById('game-status');
        const paletteEl = document.getElementById('setup-palette');

        // --- Core Rendering ---
        function createBoard() {
            boardEl.innerHTML = '';
            const boardState = game.board(); // 8x8 array: [0][0] is a8
            
            // Determine loop order based on orientation
            const rows = orientation === 'white' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
            const cols = orientation === 'white' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];

            // Get last move for highlighting
            let lastMove = null;
            if (currentHistoryIndex > 0) {
                // To get the last move, we need to peek at history logic or store it
                // We'll calculate it by comparing FENs or checking game history
                const tempGame = new Chess();
                // Load the history state up to current index
                // A simpler way: use game.history if we are at the "head", 
                // but since we scrub history, we might just store the move object in historyStack?
                // Simpler: Just rely on game.history() if we are synchronized.
                // For simplicity in this "dirty" script: calculate from game object if synchronized
                const history = game.history({ verbose: true });
                if (history.length > 0) {
                    lastMove = history[history.length - 1];
                }
            }

            rows.forEach(row => {
                cols.forEach(col => {
                    const squareDiv = document.createElement('div');
                    const isDark = (row + col) % 2 === 1;
                    const fileChar = String.fromCharCode(97 + col); // 'a'...'h'
                    const rankChar = String.fromCharCode(56 - row); // '8'...'1'
                    const squareName = fileChar + rankChar;
                    
                    squareDiv.className = `square ${isDark ? 'dark' : 'light'}`;
                    squareDiv.dataset.square = squareName;

                    // Last Move Highlight
                    if (lastMove && (squareName === lastMove.from || squareName === lastMove.to)) {
                        squareDiv.classList.add('last-move');
                    }

                    // Render Piece
                    const piece = boardState[row][col];
                    if (piece) {
                        const span = document.createElement('span');
                        span.className = `piece ${piece.color === 'w' ? 'white' : 'black'}`;
                        span.textContent = pieceIcons[piece.type];
                        squareDiv.appendChild(span);
                    }

                    // Render Coordinates (On edges)
                    // Rank (Numbers): Left side (col 0) if White, Right side (col 7) if Black? 
                    // Standard: Numbers usually on Left (a-file)
                    // Let's put Numbers on the absolute Leftmost squares of the visual grid
                    const isLeftEdge = (orientation === 'white' && col === 0) || (orientation === 'black' && col === 7);
                    const isBottomEdge = (orientation === 'white' && row === 7) || (orientation === 'black' && row === 0);

                    if (isLeftEdge) {
                        const rankLabel = document.createElement('span');
                        rankLabel.className = 'coord coord-rank';
                        rankLabel.textContent = rankChar;
                        squareDiv.appendChild(rankLabel);
                    }
                    if (isBottomEdge) {
                        const fileLabel = document.createElement('span');
                        fileLabel.className = 'coord coord-file';
                        fileLabel.textContent = fileChar;
                        squareDiv.appendChild(fileLabel);
                    }

                    squareDiv.addEventListener('click', () => handleSquareClick(squareName));
                    boardEl.appendChild(squareDiv);
                });
            });
            updateStatus();
        }

        // --- Interaction Logic ---

        function handleSquareClick(square) {
            if (isSetupMode) {
                handleSetupClick(square);
                return;
            }

            // Play Mode logic
            if (currentHistoryIndex !== historyStack.length - 1) return; // Prevent move if viewing history

            const piece = game.get(square);

            // 1. Unselect if clicking same square
            if (selectedSquare === square) {
                selectedSquare = null;
                renderHighlights();
                return;
            }

            // 2. Move Piece
            if (selectedSquare) {
                const move = game.move({
                    from: selectedSquare,
                    to: square,
                    promotion: 'q'
                });

                if (move) {
                    selectedSquare = null;
                    addToHistory();
                    createBoard();
                    return;
                }
            }

            // 3. Select Piece
            if (piece && piece.color === game.turn()) {
                selectedSquare = square;
                renderHighlights();
            } else {
                selectedSquare = null;
                renderHighlights();
            }
        }

        function handleSetupClick(square) {
            if (setupTool === 'trash') {
                game.remove(square);
            } else {
                // Tool format: 'wP' (color + type)
                const color = setupTool[0];
                const type = setupTool[1].toLowerCase();
                game.remove(square); // Remove existing
                game.put({ type: type, color: color }, square);
            }
            createBoard();
        }

        function renderHighlights() {
            document.querySelectorAll('.square').forEach(el => {
                el.classList.remove('selected', 'possible-move', 'possible-capture');
            });

            if (!selectedSquare) return;

            // Highlight Origin
            const selectedEl = document.querySelector(`[data-square="${selectedSquare}"]`);
            if (selectedEl) selectedEl.classList.add('selected');

            // Highlight Destiniations
            const moves = game.moves({ square: selectedSquare, verbose: true });
            moves.forEach(move => {
                const targetEl = document.querySelector(`[data-square="${move.to}"]`);
                if (!targetEl) return;
                if (game.get(move.to)) targetEl.classList.add('possible-capture');
                else targetEl.classList.add('possible-move');
            });
        }

        // --- History & Game State ---

        function addToHistory() {
            // Cut off future if we were in past
            if (currentHistoryIndex < historyStack.length - 1) {
                historyStack = historyStack.slice(0, currentHistoryIndex + 1);
            }
            historyStack.push(game.fen());
            currentHistoryIndex++;
            updateStatus();
        }

        function updateStatus() {
            // Turn
            const turn = game.turn() === 'w' ? 'White' : 'Black';
            turnText.textContent = turn;
            turnText.style.background = turn === 'White' ? '#fff' : '#333';
            turnText.style.color = turn === 'White' ? '#000' : '#fff';

            // Status
            if (isSetupMode) {
                statusText.textContent = "SETUP MODE";
                statusText.style.color = "#d64541";
            } else {
                statusText.style.color = "#ccc";
                if (game.in_checkmate()) statusText.textContent = "Checkmate!";
                else if (game.in_draw()) statusText.textContent = "Draw!";
                else if (game.in_check()) statusText.textContent = "Check!";
                else statusText.textContent = "";
            }

            // Buttons
            document.getElementById('btn-back').disabled = currentHistoryIndex === 0 || isSetupMode;
            document.getElementById('btn-fwd').disabled = currentHistoryIndex === historyStack.length - 1 || isSetupMode;
            document.getElementById('btn-flip').textContent = orientation === 'white' ? 'Flip ‚ü≥' : 'Flip ‚ü≤';
        }

        // --- Setup / Palette Logic ---
        
        function initPalette() {
            const pieces = ['wP', 'wN', 'wB', 'wR', 'wQ', 'wK', 'sep', 'bP', 'bN', 'bB', 'bR', 'bQ', 'bK', 'sep', 'trash'];
            paletteEl.innerHTML = '';
            
            pieces.forEach(p => {
                if (p === 'sep') {
                    const sep = document.createElement('div');
                    sep.className = 'palette-sep';
                    paletteEl.appendChild(sep);
                    return;
                }

                const div = document.createElement('div');
                div.className = 'palette-piece';
                
                if (p === 'trash') {
                    div.innerHTML = 'üóëÔ∏è';
                } else {
                    const color = p[0] === 'w' ? 'white' : 'black';
                    const type = p[1].toLowerCase();
                    div.innerHTML = `<span class="piece ${color}">${pieceIcons[type]}</span>`;
                }

                div.addEventListener('click', () => {
                    setupTool = p;
                    document.querySelectorAll('.palette-piece').forEach(el => el.classList.remove('selected-tool'));
                    div.classList.add('selected-tool');
                });

                if (p === setupTool) div.classList.add('selected-tool');
                paletteEl.appendChild(div);
            });
            
            // Add Clear Board Button
            const clearBtn = document.createElement('button');
            clearBtn.textContent = "Clear All";
            clearBtn.style.width = "100%";
            clearBtn.style.marginTop = "5px";
            clearBtn.style.background = "#c0392b";
            clearBtn.onclick = () => { game.clear(); createBoard(); };
            paletteEl.appendChild(clearBtn);
        }

        // --- Event Listeners ---

        document.getElementById('btn-back').addEventListener('click', () => {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                game.load(historyStack[currentHistoryIndex]);
                selectedSquare = null;
                createBoard();
            }
        });

        document.getElementById('btn-fwd').addEventListener('click', () => {
            if (currentHistoryIndex < historyStack.length - 1) {
                currentHistoryIndex++;
                game.load(historyStack[currentHistoryIndex]);
                selectedSquare = null;
                createBoard();
            }
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            if(confirm("Reset the board to start?")) {
                game.reset();
                historyStack = [game.fen()];
                currentHistoryIndex = 0;
                selectedSquare = null;
                isSetupMode = false;
                document.getElementById('setup-palette').style.display = 'none';
                createBoard();
            }
        });

        document.getElementById('btn-flip').addEventListener('click', () => {
            orientation = orientation === 'white' ? 'black' : 'white';
            createBoard();
        });

        document.getElementById('btn-setup').addEventListener('click', () => {
            isSetupMode = !isSetupMode;
            const btn = document.getElementById('btn-setup');
            const palette = document.getElementById('setup-palette');
            
            if (isSetupMode) {
                btn.classList.add('active-mode');
                palette.style.display = 'flex';
                btn.textContent = "Done";
                selectedSquare = null;
                renderHighlights(); // clear highlights
            } else {
                btn.classList.remove('active-mode');
                palette.style.display = 'none';
                btn.textContent = "üõ† Setup";
                // Reset history stack to this new reality
                historyStack = [game.fen()];
                currentHistoryIndex = 0;
            }
            updateStatus();
        });

        // Init
        initPalette();
        createBoard();

    </script>
</body>
</html>
